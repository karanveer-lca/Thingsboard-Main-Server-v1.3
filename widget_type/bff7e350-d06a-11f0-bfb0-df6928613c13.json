{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "avantec_widgets.select_double_value_from_flexiable_options",
    "name" : "Select double value from flexiable options",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "rpc",
      "sizeX" : 7.5,
      "sizeY" : 2,
      "resources" : [ ],
      "templateHtml" : "<div class=\"tb-rpc-button\" fxLayout=\"column\">\r\n    <div fxFlex=\"{{showTitle ? 20 : 0}}\" [ngStyle]=\"{paddingTop: showTitle ? '5px': '0px'}\"\r\n        class=\"title-container\" fxLayout=\"row\"\r\n        fxLayoutAlign=\"start center\" [fxShow]=\"showTitle\">\r\n        <span class=\"button-title\">{{title}}</span>\r\n    </div>\r\n    <div fxFlex=\"{{showTitle ? 80 : 100}}\" [ngStyle]=\"{paddingTop: showTitle ? '0px': '0px'}\"\r\n        class=\"button-container\" fxLayout=\"column\" fxLayoutAlign=\"center center\">\r\n\r\n\t\t\t<select [(ngModel)]=\"currentValue\" (change)=\"updateValue()\" \r\n\t\t\t\t[ngStyle]=\"customStyle\" \r\n\t\t\t\taria-label=\"Pick a value\" >\r\n\t\t\t\t\r\n                <option *ngFor=\"let x of options\" [value]=\"x.attributeValue\">\r\n                    {{x.optionLabel}}\r\n                </option>\r\n\t\t\t\t\r\n            </select>\r\n            \r\n    </div>\r\n    <div class=\"error-container\" [ngStyle]=\"{'background': error?.length ? 'rgba(255,255,255,0.25)' : 'none'}\"\r\n         fxLayout=\"row\" fxLayoutAlign=\"center center\">\r\n        <span class=\"button-error\">{{ error }}</span>\r\n    </div>\r\n</div>\r\n",
      "templateCss" : ".tb-rpc-button {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.tb-rpc-button .title-container {\r\n    font-size: 0.8em;\r\n    font-weight: normal;\r\n    white-space: nowrap;\r\n    opacity: 0.5;\r\n    margin: 0;\r\n}\r\n\r\n.tb-rpc-button .button-container div{\r\n    min-width: 80%\r\n}\r\n\r\n/* TC 20221020 */\r\n.tb-rpc-button .button-container select {\r\n    font-size: 1em;\r\n    font-weight: bold;\r\n    line-height: 1.5;\r\n    color: #333333;\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    width: 100%;\r\n    margin: 0;\r\n}\r\n\r\n.tb-rpc-button .button-container .mat-button{\r\n    padding: 0 0px;\r\n}\r\n\r\n.tb-rpc-button .error-container {\r\n    position: absolute;\r\n    top: 2%;\r\n    right: 0;\r\n    left: 0;\r\n    z-index: 4;\r\n    height: 14px;\r\n}\r\n\r\n.tb-rpc-button .error-container .button-error {\r\n    color: #ff3315;\r\n    white-space: nowrap;\r\n}\r\n",
      "controllerScript" : "// Based on Segment switch of string value\r\n\r\nlet valueSubscription;\r\n\r\nself.onInit = function() {\r\n    self.ctx.ngZone.run(function() {\r\n       init();\r\n       self.ctx.detectChanges(true);\r\n    });\r\n};\r\n\r\n\r\n\r\nfunction init() {\r\n    let utils       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('utils'));\r\n    //let types       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('types'));\r\n    //let toast       = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('toast'));\r\n    let translate   = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('translate'));\r\n    //let $q          = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('$q'));\r\n    let http        = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('http'));\r\n    let attributeService = self.ctx.$scope.$injector.get(self.ctx.servicesMap.get('attributeService'));\r\n    let rpcUpdateStatus = {};\r\n    let settings = utils.deepClone(self.ctx.settings) || {}; \r\n    \r\n    self.ctx.$scope.toastTargetId = 'input-widget' + utils.guid();\r\n    self.ctx.$scope.showTitle = settings.title && settings.title.length ? true : false; ////utils.defaultValue(settings.title, true);\r\n    self.ctx.$scope.title = settings.title;\r\n    //self.ctx.$scope.options = settings.options;\r\n    self.ctx.$scope.options = [];\r\n    /*for (const item of timezones) {\r\n        self.ctx.$scope.options.push({\r\n            \"optionLabel\": item.name,\r\n            \"attributeValue\": item.offset\r\n        });\r\n    }*/\r\n    \r\n    //[ngStyle]=\"{'color': currentValue!==originalValue ? 'rgba(255,0,0,0.87)' : 'none'}\" \r\n    /*function refreshTextColor() {\r\n        if (self.ctx.$scope.currentValue!==self.ctx.$scope.originalValue) {\r\n            self.ctx.$scope.customStyle = {'color': 'rgba(255,0,0,0.87)'};\r\n        } else {\r\n            self.ctx.$scope.customStyle = {'color': 'none'};\r\n        }\r\n        console.log(\"refreshTextColor():\", self.ctx.$scope.currentValue, self.ctx.$scope.originalValue, self.ctx.$scope.customStyle);\r\n    };*/\r\n    \r\n    //console.log(\"onInit\", settings);\r\n    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = \"0\";\r\n    //refreshTextColor();\r\n    \r\n    let parseValueFunction = (data) => data;        // Retrieve data\r\n    if (settings.parseValueFunction && settings.parseValueFunction.length) {\r\n        try {\r\n            parseValueFunction = new Function('data', settings.parseValueFunction);\r\n        } catch (e) {\r\n            parseValueFunction = (data) => data;\r\n        }\r\n    }\r\n    \r\n    let convertValueFunction = (value) => value;    // Update data\r\n    if (settings.convertValueFunction && settings.convertValueFunction.length) {\r\n        try {\r\n            convertValueFunction = new Function('value', settings.convertValueFunction);\r\n        } catch (e) {\r\n            convertValueFunction = (value) => value;\r\n        }\r\n    }\r\n    \r\n    // subscribe attribute & timeseries \r\n    let retrieveAttributeKey            = settings.retrieveAttributeKey;\r\n    let retrieveAttributeKeyOfMinValue  = settings.retrieveAttributeKeyOfMinValue;\r\n    let retrieveAttributeKeyOfMaxValue  = settings.retrieveAttributeKeyOfMaxValue;\r\n    let retrieveAttributeKeyOfStepValue = settings.retrieveAttributeKeyOfStepValue;\r\n    let retrieveAttributeKeyOfUnit      = settings.retrieveAttributeKeyOfUnit;\r\n    let lastAttrValue;\r\n    let lastAttrValueOfMin;\r\n    let lastAttrValueOfMax;\r\n    let lastAttrValueOfStep;\r\n    let lastAttrValueOfUnit;\r\n    function onDataUpdatedForSubscribe(subscription, apply) {\r\n        let attrValue;\r\n        let attrValueOfMin;\r\n        let attrValueOfMax;\r\n        let attrValueOfStep;\r\n        let attrValueOfUnit;\r\n        \r\n        for (let i=0; subscription.data && i<subscription.data.length; i++) {\r\n            let keyName  = subscription.data[i].dataKey.name;\r\n            if (subscription.data[i].data && subscription.data[i].data.length>0) {\r\n                let KeyValue = subscription.data[i].data[0][1];\r\n                if (retrieveAttributeKey && keyName === retrieveAttributeKey) {\r\n                    /*try { \r\n                        attrValue = parseValueFunction(KeyValue);  ////angular.fromJson(newValue)\r\n                    } catch (e){\r\n                        self.ctx.$scope.error = 'parseValueFunction(value) error!'\r\n                    }*/\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValue = KeyValue;\r\n                    }\r\n                    \r\n                } else if (retrieveAttributeKeyOfMinValue && keyName === retrieveAttributeKeyOfMinValue) {\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValueOfMin = KeyValue;\r\n                    }\r\n    \r\n                } else if (retrieveAttributeKeyOfMaxValue && keyName === retrieveAttributeKeyOfMaxValue) {\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValueOfMax = KeyValue;\r\n                    }\r\n    \r\n                } else if (retrieveAttributeKeyOfStepValue && keyName === retrieveAttributeKeyOfStepValue) {\r\n                    if (typeof KeyValue === 'number' && isFinite(KeyValue)) {\r\n                        attrValueOfStep = KeyValue;\r\n                    }\r\n    \r\n                } else if (retrieveAttributeKeyOfUnit && keyName === retrieveAttributeKeyOfUnit) {\r\n                    attrValueOfUnit = String(KeyValue);\r\n    \r\n                } else {\r\n                    console.log(\"unkown data:subscription.data[%d]\", i);\r\n                    console.log(subscription.data[i]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        //console.log(attrValueOfMin, attrValueOfMax, attrValueOfStep, attrValueOfUnit, attrValue);\r\n        //console.log(lastAttrValueOfMin, lastAttrValueOfMax, lastAttrValueOfStep, lastAttrValueOfUnit);\r\n        if (attrValueOfMin !== lastAttrValueOfMin || attrValueOfMax !== lastAttrValueOfMax ||\r\n            attrValueOfStep !== lastAttrValueOfStep || attrValueOfUnit !== lastAttrValueOfUnit) {\r\n\r\n            if (attrValueOfMin)  lastAttrValueOfMin = attrValueOfMin;\r\n            if (attrValueOfMax)  lastAttrValueOfMax = attrValueOfMax;\r\n            if (attrValueOfStep) lastAttrValueOfStep = attrValueOfStep; \r\n            if (attrValueOfUnit) lastAttrValueOfUnit = attrValueOfUnit;\r\n            \r\n            if (attrValueOfMin && attrValueOfMax && attrValueOfStep) {\r\n                let factor = 100;\r\n                if (self.ctx.widgetConfig.decimals && self.ctx.widgetConfig.decimals>=0) {\r\n                    factor = Math.pow(10, self.ctx.widgetConfig.decimals);\r\n                }\r\n                \r\n                self.ctx.$scope.options = [];\r\n                let fMin = factor*attrValueOfMin;\r\n                let fMax = factor*attrValueOfMax;\r\n                let fStep = factor*attrValueOfStep;\r\n                for (let val=fMin, i=0; val<fMax+fStep; i++, val=fMin+fStep*i){\r\n                ////for (let val=factor*attrValueOfMin, i=0; val<factor*attrValueOfMax+factor*attrValueOfStep; i++, val=factor*attrValueOfMin+factor*attrValueOfStep*i){\r\n                    let attributeValue = val / factor;\r\n                    let optionLabel;\r\n                    if (self.ctx.widgetConfig.decimals && self.ctx.widgetConfig.decimals>=0) {\r\n                        optionLabel = attributeValue.toFixed(self.ctx.widgetConfig.decimals);\r\n                    } else {\r\n                        optionLabel = attributeValue.toString();\r\n                    }\r\n                    if (attrValueOfUnit && attrValueOfUnit.length) {\r\n                        optionLabel = optionLabel + \" \" + attrValueOfUnit;\r\n                    }\r\n                    let item = {\r\n                        \"optionLabel\" : optionLabel,\r\n                        \"attributeValue\" : String(attributeValue)\r\n                    };\r\n                    self.ctx.$scope.options.push(item);\r\n                }\r\n            }\r\n            \r\n        }\r\n        \r\n        if (attrValue) {\r\n            self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = String(attrValue);\r\n            //refreshTextColor();\r\n        }\r\n        \r\n        if (apply) {\r\n            self.ctx.detectChanges(); //self.ctx.$scope.$digest();\r\n        }\r\n        \r\n        //console.log(\"onDataUpdatedForSubscribe():\", self.ctx.$scope.currentValue, self.ctx.$scope.originalValue, attrValue, apply);\r\n    }\r\n    function onDataUpdateErrorForSubscribe(subscription, e) {\r\n        var exceptionData = utils.parseException(e);\r\n        var errorText = exceptionData.name;\r\n        if (exceptionData.message) {\r\n            errorText += ': ' + exceptionData.message;\r\n        }\r\n        self.ctx.$scope.error = errorText;\r\n        console.log(\"onDataUpdateErrorForSubscribe(): errorText=\", errorText);\r\n    }\r\n    function subscribeAttributesOrTimeseries(type, entityType, entityId /*, retrieveMethod, key*/) {\r\n        var valueSubscriptionInfo = [{\r\n            type:       type,\r\n            entityType: entityType,\r\n            entityId:   entityId\r\n        }];\r\n        \r\n        ////if (retrieveMethod == 'attribute') {\r\n            ////valueSubscriptionInfo[0].attributes = [ {name: key}];\r\n            valueSubscriptionInfo[0].attributes = [];\r\n            if (retrieveAttributeKey && retrieveAttributeKey.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKey } );\r\n            }\r\n            if (retrieveAttributeKeyOfMinValue && retrieveAttributeKeyOfMinValue.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfMinValue } );\r\n            }\r\n            if (retrieveAttributeKeyOfMaxValue && retrieveAttributeKeyOfMaxValue.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfMaxValue } );\r\n            }\r\n            if (retrieveAttributeKeyOfStepValue && retrieveAttributeKeyOfStepValue.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfStepValue } );\r\n            }\r\n            if (retrieveAttributeKeyOfUnit && retrieveAttributeKeyOfUnit.length) {\r\n                valueSubscriptionInfo[0].attributes.push( { name: retrieveAttributeKeyOfUnit } );\r\n            }\r\n        ////} else {\r\n        ////    valueSubscriptionInfo[0].timeseries = [{name: key}];\r\n        ////}\r\n        \r\n        var subscriptionOptions = {\r\n            callbacks: {\r\n                onDataUpdated: onDataUpdatedForSubscribe,\r\n                onDataUpdateError: onDataUpdateErrorForSubscribe\r\n            }\r\n        };\r\n        self.ctx.subscriptionApi.createSubscriptionFromInfo (\r\n            'latest', valueSubscriptionInfo, subscriptionOptions, false, true).subscribe( //types.widgetType.latest.value\r\n            (subscription) => {\r\n                valueSubscription = subscription;\r\n            }\r\n        );    \r\n    }\r\n    \r\n    // update attribute\r\n    function updateAttributes(entityType, entityId, attributeScope, key, value) { \r\n        let attributes = [];\r\n        attributes.push({\r\n            \"key\": key,                             // attribute name,\r\n            \"value\": convertValueFunction(value)    // attribute value\r\n        });\r\n\r\n        ////attributeService.saveEntityAttributes(self.ctx.datasources[0].entityType, self.ctx.datasources[0].entityId,\r\n        attributeService.saveEntityAttributes({\"entityType\":entityType, \"id\":entityId}, \r\n            attributeScope, attributes).subscribe(\r\n            function success() {\r\n                retrieveValue();  //self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                self.ctx.$scope.error = \"\";\r\n            },\r\n            function fail(rejection) {\r\n                var errorText = rejection.status + \": \" + rejection.statusText;\r\n                if (self.ctx.settings.showError) {\r\n                    self.ctx.$scope.error =errorText\r\n                        \r\n                }\r\n                console.log(\"updateAttributes(): errorText=\", errorText);\r\n            }\r\n        );\r\n    }\r\n    \r\n    // update timeseries \r\n    function saveEntityTimeseries(entityType, entityId, telemetries) {\r\n        var telemetriesData = {};\r\n        for (var a = 0; a < telemetries.length; a++) {\r\n            if (typeof telemetries[a].value !== 'undefined' && telemetries[a].value !== null) {\r\n                telemetriesData[telemetries[a].key] = telemetries[a].value;\r\n            }\r\n        }\r\n        if (Object.keys(telemetriesData).length) {\r\n            var url = '/api/plugins/telemetry/' + entityType + '/' + entityId + '/timeseries/scope';\r\n            return http.post(url, telemetriesData);\r\n        }\r\n        return null;\r\n    }\r\n    function updateTimeseries(entityType, entityId, key, value) {\r\n        //var datasource = self.ctx.datasources[0];\r\n        let observable = saveEntityTimeseries(\r\n            entityType,     // datasource.entityType,\r\n            entityId,       // datasource.entityId,\r\n            [\r\n                {\r\n                    key: key,\r\n                    value: convertValueFunction(value)\r\n                }\r\n            ]\r\n        );\r\n        if (observable) {\r\n            observable.subscribe(\r\n                function success() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showSuccessToast(translate.instant('widgets.input-widgets.update-successful'), 1000, 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                    retrieveValue();    //$scope.originalValue = $scope.currentValue = value;\r\n                },\r\n                function fail() {\r\n                    /*if (settings.showResultMessage) {\r\n                        $scope.showErrorToast(translate.instant('widgets.input-widgets.update-failed'), 'bottom', 'left', $scope.toastTargetId);\r\n                    }*/\r\n                var errorText = $translate.instant('widgets.input-widgets.update-failed');\r\n                self.ctx.$scope.error = errorText;\r\n                console.log(\"updateTimeseries(): errorText=\", errorText);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // RPC retrieve value\r\n    /*function rpcRetrieveValue(method, timeout) {\r\n        if (method && method.length) {\r\n            self.ctx.$scope.error = '';\r\n            self.ctx.controlApi.sendTwoWayCommand(method, null, timeout).subscribe(\r\n                function success(responseBody) {\r\n                    ////self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = responseBody;\r\n                    self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = parseValueFunction(responseBody);\r\n\r\n                    ////self.ctx.$scope.$digest(); // Error: $digest already in progress\r\n                },\r\n                function fail() {\r\n                    self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                }\r\n            );\r\n        } else {\r\n            self.ctx.$scope.error = \"retrieveRPCMethod is null.\";\r\n        }\r\n    }*/\r\n    // RPC update value\r\n    function rpcUpdateValue(method, value, timeout) {\r\n        if (rpcUpdateStatus.executingUpdateValue) {\r\n            rpcUpdateStatus.scheduledValue = value;\r\n            return;\r\n        } else {\r\n            rpcUpdateStatus.scheduledValue = null;\r\n            rpcUpdateStatus.rpcValue = value;\r\n            rpcUpdateStatus.executingUpdateValue = true;\r\n        }\r\n        self.ctx.$scope.error = '';\r\n        self.ctx.controlApi.sendOneWayCommand(method, convertValueFunction(value), timeout).subscribe(\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                if (rpcUpdateStatus.scheduledValue !== null && rpcUpdateStatus.scheduledValue != rpcUpdateStatus.rpcValue) {\r\n                    rpcUpdateValue(rpcUpdateStatus.scheduledValue);\r\n                } else {\r\n                    retrieveValue(); // self.ctx.$scope.originalValue = self.ctx.$scope.currentValue = value;\r\n                }\r\n            },\r\n            () => {\r\n                rpcUpdateStatus.executingUpdateValue = false;\r\n                self.ctx.$scope.error = self.ctx.defaultSubscription.rpcErrorText;\r\n                console.log(\"rpcUpdateValue(): errorText=\", self.ctx.$scope.error);\r\n            }\r\n        );\r\n    }\r\n\r\n    // update value\r\n    self.ctx.$scope.updateValue = function() {\r\n        //refreshTextColor();\r\n        \r\n        var newValue = self.ctx.$scope.currentValue * 1;\r\n        console.log(\"updateValue():\", self.ctx.$scope.currentValue, newValue);\r\n\r\n        if (settings.updateMethod === \"SHARED_SCOPE\" || settings.updateMethod === \"SERVER_SCOPE\") {\r\n            updateAttributes(\"DEVICE\", //types.entityType.device, \r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateMethod, \r\n                settings.updateAttributeKey, \r\n                newValue);\r\n                \r\n        } else if (settings.updateMethod === \"timeseries\") {\r\n            updateTimeseries(\"DEVICE\", // types.entityType.device,  types.constant.js\r\n                self.ctx.defaultSubscription.targetDeviceId, \r\n                settings.updateAttributeKey, \r\n                newValue);\r\n                \r\n        } else if (settings.updateMethod === \"rpc\") {\r\n            rpcUpdateValue(settings.updateRPCMethod, \r\n                newValue, \r\n                settings.requestTimeout);\r\n            \r\n        } else {\r\n            self.ctx.$scope.error = \"updateMethod is error!\";\r\n\r\n        }\r\n    }\r\n\r\n    // retrieve value\r\n    var firstRetrieveValue = true;\r\n    function retrieveValue() {\r\n        let rpcEnabled = self.ctx.defaultSubscription.rpcEnabled;\r\n        let isSimulated = self.ctx.$scope.widgetEditMode;\r\n        if (!rpcEnabled) {\r\n            self.ctx.$scope.error = 'Target device is not set!';\r\n        } else {\r\n            if (!isSimulated) {\r\n                ////if (settings.retrieveMethod == 'rpc') {\r\n                ////    rpcRetrieveValue(settings.retrieveRPCMethod, settings.requestTimeout);\r\n                ////} else if (settings.retrieveMethod == 'attribute' || settings.retrieveMethod == 'timeseries') {\r\n                    if (firstRetrieveValue) {\r\n                        subscribeAttributesOrTimeseries(\"entity\", // types.datasourceType.entity, in types.constant.js\r\n                            \"DEVICE\", //types.entityType.device, in types.constant.js\r\n                            self.ctx.defaultSubscription.targetDeviceId/*, \r\n                            settings.retrieveMethod, \r\n                            settings.retrieveAttributeKey*/);\r\n                    }\r\n                ////}\r\n            } \r\n        }\r\n        \r\n        firstRetrieveValue = false;\r\n    }\r\n    \r\n    retrieveValue();\r\n};\r\n\r\nself.onResize = function() {\r\n};\r\n\r\nself.onDestory = function() {\r\n    if (valueSubscription) {\r\n        self.ctx.subscriptionApi.removeSubscription(valueSubscription.id);\r\n    }\r\n};\r\n\r\n/*self.onDataUpdated = function() {\r\n    try{\r\n        self.ctx.$scope.currentValue = self.ctx.$scope.originalValue = self.ctx.data[0].data[0][1];\r\n        self.ctx.$scope.$digest();\r\n    } catch (e) {\r\n        console.log(e);\r\n    }\r\n}*/\r\n\r\n/*self.typeParameters = function() {\r\n    return {\r\n        maxDatasources: 1, // Maximum allowed datasources for this widget, -1 - unlimited\r\n        maxDataKeys: 1 //Maximum allowed data keys for this widget, -1 - unlimited\r\n    }\r\n};*/\r\n\r\n\r\n/*\"retrieveMethod\": {\r\n    \"title\": \"Retrieve double value using method\",\r\n    \"type\": \"string\",\r\n    \"default\": \"rpc\"\r\n},\r\n\"retrieveAttributeKey\": {\r\n    \"title\": \"Retrieve Attribute/Timeseries value key (only when subscribe for attribute/timeseries method)\",\r\n    \"type\": \"string\",\r\n    \"default\": \"\"\r\n},\r\n\"retrieveRPCMethod\": {\r\n    \"title\": \"Retrieve value using RPC method (only when call RPC get value method)\",\r\n    \"type\": \"string\",\r\n    \"default\": \"\"\r\n},\r\n\"parseValueFunction\": {\r\n    \"title\": \"Parse value function, f(data), returns double value\",\r\n    \"type\": \"string\",\r\n    \"default\": \"return data; \"\r\n},\r\n----------------------------------------------------------\r\n{\r\n            \"key\": \"retrieveMethod\",\r\n            \"type\": \"rc-select\",\r\n            \"multiple\": false,\r\n            \"items\": [\r\n                {\r\n                    \"value\": \"none\",\r\n                    \"label\": \"Don't retrieve\"\r\n                },\r\n                {\r\n                    \"value\": \"attribute\",\r\n                    \"label\": \"Subscribe for attribute\"\r\n                },\r\n                {\r\n                    \"value\": \"timeseries\",\r\n                    \"label\": \"Subscribe for timeseries\"\r\n                },\r\n                {\r\n                    \"value\": \"rpc\",\r\n                    \"label\": \"Call RPC get value method\"\r\n                }\r\n            ]\r\n        },\r\n        \"retrieveAttributeKey\",\r\n        \"retrieveRPCMethod\",\r\n        {\r\n            \"key\": \"parseValueFunction\",\r\n            \"type\": \"javascript\"\r\n        },\r\n\r\n*/\r\n",
      "settingsSchema" : "{\n    \"schema\": {\n        \"type\": \"object\",\n        \"title\": \"Settings\",\n        \"properties\": {\n            \"title\": {\n                \"title\": \"Widget title\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"retrieveAttributeKey\": {\n                \"title\": \"Device attribute key\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfMinValue\": {\n                \"title\": \"Device attribute key of Min value\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfMaxValue\": {\n                \"title\": \"Device attribute key of Max value\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfStepValue\": {\n                \"title\": \"Device attribute key of Step value\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"retrieveAttributeKeyOfUnit\": {\n                \"title\": \"Device attribute key of Unit\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \n            \"updateMethod\": {\n                \"title\": \"Update double value using method\",\n                \"type\": \"string\",\n                \"default\": \"rpc\"\n            },\n            \"updateAttributeKey\": {\n                \"title\": \"Update Attribute/Timeseries value key (only when update for attribute/timeseries method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"updateRPCMethod\": {\n                \"title\": \"Update value using RPC method (only when call RPC set value method)\",\n                \"type\": \"string\",\n                \"default\": \"\"\n            },\n            \"convertValueFunction\": {\n                \"title\": \"Convert value function, f(value), returns payload used by RPC set value method\",\n                \"type\": \"string\",\n                \"default\": \"return value; /* console.log(value); */\"\n            },\n\n            \"requestTimeout\": {\n                \"title\": \"RPC request timeout\",\n                \"type\": \"number\",\n                \"default\": 5000\n            },\n\n            \"required\": [\n                \"retrieveAttributeKey\",\n                \"retrieveAttributeKeyOfMinValue\",\n                \"retrieveAttributeKeyOfMaxValue\",\n                \"retrieveAttributeKeyOfStepValue\",\n                \"updateMethod\"\n            ]\n        }\n    },\n    \"form\": [\n        \"title\",\n\n        \"retrieveAttributeKey\",\n        \"retrieveAttributeKeyOfMinValue\",\n        \"retrieveAttributeKeyOfMaxValue\",\n        \"retrieveAttributeKeyOfStepValue\",\n        \"retrieveAttributeKeyOfUnit\",\n        \n        {\n            \"key\": \"updateMethod\",\n            \"type\": \"rc-select\",\n            \"multiple\": false,\n            \"items\": [\n                {\n                    \"value\": \"SHARED_SCOPE\",\n                    \"label\": \"Update shared attribute\"\n                },\n                {\n                    \"value\": \"SERVER_SCOPE\",\n                    \"label\": \"Update server attribute\"\n                },\n                {\n                    \"value\": \"timeseries\",\n                    \"label\": \"Update timeseries\"\n                },\n                {\n                    \"value\": \"rpc\",\n                    \"label\": \"Call RPC set value method\"\n                }\n            ]\n        },\n        \"updateAttributeKey\",\n        \"updateRPCMethod\",\n        {\n            \"key\": \"convertValueFunction\",\n            \"type\": \"javascript\"\n        },\n        \n        \"requestTimeout\"\n    ]\n}",
      "dataKeySettingsSchema" : "{}\r\n",
      "defaultConfig" : "{\"showTitle\":true,\"backgroundColor\":\"#e6e7e8\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"optionStyle\":{\"orientation\":\"column\",\"isRaised\":true,\"checkedOption\":{\"isPrimary\":true},\"uncheckedOption\":{\"isPrimary\":false}},\"options\":[{\"optionLabel\":\"Option1 Label\",\"attributeValue\":\"option1\"},{\"optionLabel\":\"Option2 Label\",\"attributeValue\":\"option2\"}],\"retrieveMethod\":\"rpc\",\"retrieveAttributeKey\":\"value\",\"retrieveRPCMethod\":\"getValue\",\"parseValueFunction\":\"/* console.log(data); */\\nreturn data;\",\"updateMethod\":\"rpc\",\"updateAttributeKey\":\"value\",\"updateRPCMethod\":\"setValue\",\"convertValueFunction\":\"/* console.log(value); */\\nreturn value;\",\"requestTimeout\":5000},\"title\":\"Select double value from flexiable options\",\"showTitleIcon\":false,\"titleIcon\":\"more_horiz\",\"iconColor\":\"rgba(0, 0, 0, 0.87)\",\"iconSize\":\"24px\",\"titleTooltip\":\"\",\"dropShadow\":true,\"enableFullscreen\":false,\"widgetStyle\":{},\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"useDashboardTimewindow\":true,\"displayTimewindow\":true,\"showLegend\":false,\"actions\":{},\"targetDeviceAliases\":[]}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "bff7e350-d06a-11f0-bfb0-df6928613c13"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}