{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "sld_diagram",
    "name" : "SLD Diagram",
    "deprecated" : false,
    "image" : "tb-image;/api/images/tenant/SLD Diagram Preview.png",
    "description" : "A Interactive SLD diagram widget that shows a plant's floorplan with all the machines placed on top of it",
    "descriptor" : {
      "type" : "static",
      "sizeX" : 7.5,
      "sizeY" : 3,
      "resources" : [ ],
      "templateHtml" : "<div class=\"fp-wrap\" #wrap>\r\n  <img class=\"fp-bg\" [src]=\"bgUrl | image | async\" (load)=\"onBgLoad($event)\" alt=\"floorplan\"/>\r\n  <div\r\n    class=\"fp-label\"\r\n    *ngFor=\"let d of labels; trackBy: trackById\"\r\n    [style.left.px]=\"d.__pxLeft || 0\"\r\n    [style.top.px]=\"d.__pxTop || 0\"\r\n    (click)=\"clickDevice(d)\"\r\n    [attr.title]=\"d?.name\"\r\n  >\r\n    <!-- Machine Details Card -->\r\n    <div class=\"fp-card\">\r\n      <!-- Machine chip -->\r\n      <div\r\n        class=\"fp-chip\"\r\n        [ngStyle]=\"{ 'background-color': d.color || 'rgba(15,36,62,0.92)' }\"\r\n      >\r\n        {{ d?.label || d?.name }}\r\n      </div>\r\n      <!-- Dynamic telemetry data display -->\r\n      <div class=\"fp-telemetry\" *ngIf=\"getTelemetryKeys(d).length > 0\">\r\n        <div class=\"fp-data-row\" *ngFor=\"let key of getTelemetryKeys(d)\">\r\n          <span class=\"fp-data-label\">{{ key.label }}:</span>\r\n          <span class=\"fp-data-value\">{{ key.displayValue }}</span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n  <!-- Legend (optional) -->\r\n  <div class=\"fp-legend\">\r\n    <span class=\"dot dot-on\"></span> Active\r\n    <span class=\"dot dot-off\"></span> Inactive\r\n  </div>\r\n</div>\r\n<style>\r\n  .fp-wrap {\r\n    position: relative;\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    background: #0f243e08;\r\n  }\r\n  .fp-bg {\r\n    position: absolute;\r\n    inset: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    object-fit: contain;\r\n    user-select: none;\r\n    pointer-events: none;\r\n  }\r\n  .fp-label {\r\n    position: absolute;\r\n    transform: translate(-50%, -50%);\r\n    cursor: pointer;\r\n    z-index: 10;\r\n  }\r\n  .fp-card {\r\n    background: rgba(255, 255, 255, 0.95);\r\n    border-radius: 8px;\r\n    padding: 6px;\r\n    box-shadow: 0 6px 20px rgba(0,0,0,.4), 0 3px 8px rgba(0,0,0,.3);\r\n    backdrop-filter: blur(4px);\r\n    border: 1px solid rgba(255, 255, 255, 0.8);\r\n    transition: transform 0.2s ease, box-shadow 0.2s ease;\r\n    overflow: hidden;\r\n  }\r\n  .fp-card:hover {\r\n    transform: scale(1.05);\r\n    box-shadow: 0 8px 24px rgba(0,0,0,.5), 0 4px 10px rgba(0,0,0,.35);\r\n  }\r\n  .fp-chip {\r\n    padding: 6px 10px;\r\n    border-radius: 6px;\r\n    color: #fff;\r\n    box-shadow: 0 4px 10px rgba(0,0,0,.35), 0 2px 4px rgba(0,0,0,.2);\r\n    font-size: 12px;\r\n    font-weight: 600;\r\n    line-height: 1.2;\r\n    white-space: nowrap;\r\n    user-select: none;\r\n    text-align: center;\r\n    margin-bottom: 2px;\r\n  }\r\n  .fp-telemetry {\r\n    max-height: 0;\r\n    opacity: 0;\r\n    overflow: hidden;\r\n    margin-top: 0;\r\n    padding-top: 0;\r\n    border-top: 1px solid transparent;\r\n    transition: max-height 0.3s ease, opacity 0.3s ease, margin-top 0.3s ease, padding-top 0.3s ease, border-top-color 0.3s ease;\r\n  }\r\n  .fp-card:hover .fp-telemetry {\r\n    max-height: 500px;\r\n    opacity: 1;\r\n    margin-top: 6px;\r\n    padding-top: 6px;\r\n    border-top-color: rgba(0,0,0,.1);\r\n  }\r\n  .fp-data-row {\r\n    font-size: 11px;\r\n    color: #333;\r\n    background: rgba(240, 245, 250, 0.8);\r\n    border-radius: 4px;\r\n    padding: 4px 8px;\r\n    margin-bottom: 3px;\r\n    white-space: nowrap;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    transition: background 0.2s ease;\r\n  }\r\n  .fp-data-row:hover {\r\n    background: rgba(230, 240, 250, 1);\r\n  }\r\n  .fp-data-row:last-child {\r\n    margin-bottom: 0;\r\n  }\r\n  .fp-data-label {\r\n    font-weight: 600;\r\n    margin-right: 8px;\r\n    color: #555;\r\n  }\r\n  .fp-data-value {\r\n    font-weight: 500;\r\n    color: #0f243e;\r\n  }\r\n  .fp-legend {\r\n    position: absolute;\r\n    right: 8px;\r\n    bottom: 8px;\r\n    background: rgba(15,36,62,.85);\r\n    color: #fff;\r\n    font-size: 11px;\r\n    padding: 8px 12px;\r\n    border-radius: 6px;\r\n    display: flex;\r\n    gap: 12px;\r\n    align-items: center;\r\n    box-shadow: 0 2px 8px rgba(0,0,0,.3);\r\n  }\r\n  .dot {\r\n    display: inline-block;\r\n    width: 10px;\r\n    height: 10px;\r\n    border-radius: 50%;\r\n    margin-right: 4px;\r\n    vertical-align: middle;\r\n    box-shadow: 0 1px 3px rgba(0,0,0,.35);\r\n  }\r\n  .dot-on  { background: rgba(76,175,80,0.9); }\r\n  .dot-off { background: rgba(244,67,54,0.9); }\r\n</style>",
      "templateCss" : "",
      "controllerScript" : "/*\r\n * Floorplan widget for ThingsBoard PE (runtime display)\r\n *\r\n * This JavaScript code implements a static widget that renders a floorplan\r\n * image, places chips for each device from a configured device group, and\r\n * displays dynamic telemetry data (e.g., runtime in minutes) of an active \r\n * job card related to each device. All configuration comes from the widget's \r\n * Settings form (see the corresponding settings schema).  When a chip is \r\n * clicked, the widget navigates to a target dashboard state with the active \r\n * job card as a state parameter.\r\n */\r\n\r\nself.onInit = function () {\r\n  // Pull the settings object injected by ThingsBoard.  The settings form\r\n  // schema defines the properties available here.  See the schema in\r\n  // floorplan_settings_schema.json for details.\r\n  var settings = self.ctx.settings || {};\r\n\r\n  // Parse the positions field.  The settings form stores it as a JSON\r\n  // string.  If the user edits the field, it may not parse, so wrap in\r\n  // try/catch and fall back to an empty array.\r\n  function parsePositions(value) {\r\n    if (Array.isArray(value)) {\r\n      console.log('[FP] parsePositions: positions provided as array:', value);\r\n      return value;\r\n    } else if (typeof value === 'string' && value.trim()) {\r\n      try {\r\n        var parsed = JSON.parse(value);\r\n        console.log('[FP] parsePositions: parsed positions from JSON string:', parsed);\r\n        return parsed;\r\n      } catch (err) {\r\n        console.warn('[FP] Failed to parse positions JSON from settings:', err);\r\n        return [];\r\n      }\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Parse the data keys field. Same approach as positions.\r\n  function parseDataKeys(value) {\r\n    if (Array.isArray(value)) {\r\n      console.log('[FP] parseDataKeys: dataKeys provided as array:', value);\r\n      return value;\r\n    } else if (typeof value === 'string' && value.trim()) {\r\n      try {\r\n        var parsed = JSON.parse(value);\r\n        console.log('[FP] parseDataKeys: parsed dataKeys from JSON string:', parsed);\r\n        return parsed;\r\n      } catch (err) {\r\n        console.warn('[FP] Failed to parse dataKeys JSON from settings:', err);\r\n        return [];\r\n      }\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Construct a configuration object using settings and sensible defaults.\r\n  var CONFIG = {\r\n    imageUrl: settings.imageUrl || '',\r\n    groupId: settings.groupId || '',\r\n    positions: parsePositions(settings.positions),\r\n    dataKeys: parseDataKeys(settings.dataKeys),\r\n    targetStateId: settings.targetStateId || '',\r\n    stateParamName: settings.stateParamName || '',\r\n    pollInterval: typeof settings.pollInterval === 'number' ? settings.pollInterval : 5000\r\n  };\r\n\r\n  // Log resolved configuration for debugging.  This helps identify\r\n  // whether values were correctly passed from the settings form.\r\n  console.log('[FP] Resolved CONFIG:', CONFIG);\r\n\r\n  var ctx = self.ctx;\r\n  var $scope = ctx.$scope;\r\n  var $injector = $scope.$injector;\r\n\r\n  // Obtain ThingsBoard services via injector.  These services are\r\n  // documented in the ThingsBoard widget API and allow querying\r\n  // entities, relations and telemetry.\r\n  var entityService    = $injector.get(ctx.servicesMap.get('entityService'));\r\n  var relationService  = $injector.get(ctx.servicesMap.get('entityRelationService'));\r\n  var attributeService = $injector.get(ctx.servicesMap.get('attributeService'));\r\n\r\n  // Bindings used in the HTML template.  They are attached to $scope so\r\n  // that Angular can access them in the HTML.  Do not rename these\r\n  // properties without updating the HTML.\r\n  $scope.bgUrl       = '';\r\n  $scope.labels      = [];\r\n  $scope.trackById   = function (_i, item) { return (item && item.id) || _i; };\r\n  $scope.onBgLoad    = onBgLoad;\r\n  $scope.clickDevice = clickDevice;\r\n  $scope.getTelemetryKeys = function(label) {\r\n    if (!CONFIG.dataKeys || !label || !label.telemetry) {\r\n      return [];\r\n    }\r\n    return CONFIG.dataKeys.map(function(dk) {\r\n      var value = label.telemetry[dk.key];\r\n      var displayValue = value != null ? value + (dk.unit || '') : '--';\r\n      return {\r\n        key: dk.key,\r\n        label: dk.label || dk.key,\r\n        displayValue: displayValue\r\n      };\r\n    });\r\n  };\r\n\r\n  // Internal state for image layout and polling timers.\r\n  var layout = { natW: 0, natH: 0, boxL: 0, boxT: 0, boxW: 0, boxH: 0 };\r\n  var timers = new Map();\r\n\r\n  console.log('[FP] Widget init with settings:', settings);\r\n  applyConfig();\r\n  loadGroupDevices();\r\n\r\n  // Clean up timers on destroy to avoid memory leaks.\r\n  self.onDestroy = function () {\r\n    timers.forEach(function (t) { clearInterval(t); });\r\n    timers.clear();\r\n    console.log('[FP] Widget destroyed, timers cleared');\r\n  };\r\n\r\n  /**\r\n   * Apply configuration from settings.  Warn if essential values are\r\n   * missing so that the user knows to configure them.  Assign\r\n   * background image URL.\r\n   */\r\n  function applyConfig() {\r\n    if (!CONFIG.imageUrl) {\r\n      console.warn('[FP] imageUrl setting is empty. Please configure a background image in the settings.');\r\n    }\r\n    if (!CONFIG.groupId) {\r\n      console.warn('[FP] groupId setting is empty. Please configure a Device Group ID in the settings.');\r\n    }\r\n    if (!CONFIG.targetStateId) {\r\n      console.warn('[FP] targetStateId setting is empty. Navigation on click will be disabled.');\r\n    }\r\n    if (!CONFIG.stateParamName) {\r\n      console.warn('[FP] stateParamName setting is empty. Navigation on click will be disabled.');\r\n    }\r\n    if (!CONFIG.dataKeys || CONFIG.dataKeys.length === 0) {\r\n      console.warn('[FP] dataKeys setting is empty. No telemetry data will be displayed.');\r\n    }\r\n    var normImg = normalizeImageUrl(CONFIG.imageUrl);\r\n    console.log('[FP] applyConfig: imageUrl setting =', CONFIG.imageUrl, ', normalized =', normImg);\r\n    $scope.bgUrl = normImg;\r\n    ctx.detectChanges();\r\n  }\r\n\r\n  /**\r\n   * Normalize tenant image URLs by stripping the tb-image prefix.\r\n   */\r\n  function normalizeImageUrl(url) {\r\n    return url ? url.toString().replace(/^tb-image[:;]\\s*/i, '').trim() : '';\r\n  }\r\n\r\n  /**\r\n   * Handler for <img> load event.  Records natural dimensions and\r\n   * recomputes positions so chips stay aligned with the image.\r\n   */\r\n  function onBgLoad(ev) {\r\n    try {\r\n      var img = ev && ev.target ? ev.target : null;\r\n      layout.natW = (img && img.naturalWidth)  || 0;\r\n      layout.natH = (img && img.naturalHeight) || 0;\r\n      recomputePixelPositions();\r\n      ctx.detectChanges();\r\n      console.log('[FP] onBgLoad: natural size =', layout.natW, 'x', layout.natH);\r\n    } catch (e) {\r\n      console.warn('[FP] onBgLoad error:', e);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compute the bounding rectangle of the widget container.  This is\r\n   * used to calculate where to place chips relative to the floorplan.\r\n   */\r\n  function getHostRect() {\r\n    var host = ctx.$container ? ctx.$container[0] :\r\n               (ctx.$scope && ctx.$scope.$element && ctx.$scope.$element[0]);\r\n    if (!host || !host.getBoundingClientRect) return { left:0, top:0, width:0, height:0 };\r\n    var r = host.getBoundingClientRect();\r\n    return { left:r.left, top:r.top, width:r.width, height:r.height };\r\n  }\r\n\r\n  function clamp01(v){ return v < 0 ? 0 : (v > 1 ? 1 : v); }\r\n\r\n  /**\r\n   * Convert percentage coordinates to pixel offsets based on the\r\n   * object-fit: contain layout.  Called whenever the image loads or\r\n   * the widget is resized.\r\n   */\r\n  function recomputePixelPositions() {\r\n    var r = getHostRect();\r\n    if (!r.width || !r.height || !layout.natW || !layout.natH) return;\r\n    var s  = Math.min(r.width / layout.natW, r.height / layout.natH);\r\n    layout.boxW = layout.natW * s;\r\n    layout.boxH = layout.natH * s;\r\n    layout.boxL = (r.width  - layout.boxW) * 0.5;\r\n    layout.boxT = (r.height - layout.boxH) * 0.5;\r\n    ($scope.labels || []).forEach(function (d) {\r\n      var px = clamp01((+d.x) / 100);\r\n      var py = clamp01((+d.y) / 100);\r\n      d.__pxLeft = Math.round(layout.boxL + px * layout.boxW);\r\n      d.__pxTop  = Math.round(layout.boxT + py * layout.boxH);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Load all devices from the configured group and build label objects.\r\n   * Each label corresponds to a device and is placed at the configured\r\n   * coordinates.  After building labels, runtime polling begins.\r\n   */\r\n  function loadGroupDevices() {\r\n    if (!CONFIG.groupId) {\r\n      $scope.labels = [];\r\n      ctx.detectChanges();\r\n      return;\r\n    }\r\n    var filter = { type: 'entityGroup', groupType: 'DEVICE', entityGroup: CONFIG.groupId };\r\n    console.log('[FP] Loading devices for group:', CONFIG.groupId);\r\n    entityService.findEntityInfosByFilterAndName(filter, '').subscribe(\r\n      function (pageData) {\r\n        var rows = pageData && pageData.data ? pageData.data : [];\r\n        console.log('[FP] Devices fetched:', rows.length);\r\n        buildLabels(rows);\r\n        recomputePixelPositions();\r\n        ctx.detectChanges();\r\n        // Start polling telemetry for each device\r\n        $scope.labels.forEach(initTelemetryPolling);\r\n      },\r\n      function (err) {\r\n        console.error('[FP] Device fetch failed:', err);\r\n        $scope.labels = [];\r\n        ctx.detectChanges();\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Create label objects from devices using the configured positions.  The\r\n   * positions array contains objects with keys: by (name or id), match,\r\n   * x, y and label.  Devices without a matching position are ignored.\r\n   */\r\n  function buildLabels(entities) {\r\n    var byName = {}, byId = {};\r\n    CONFIG.positions.forEach(function (p) {\r\n      if (!p || typeof p.match === 'undefined') return;\r\n      if ((p.by || 'name') === 'id') byId[p.match] = p;\r\n      else byName[p.match] = p;\r\n    });\r\n    var out = [];\r\n    entities.forEach(function (e) {\r\n      if (!e) return;\r\n      var idObj = e.id || e.entityId || {};\r\n      var id    = idObj.id || (typeof idObj === 'string' ? idObj : null);\r\n      if (!id) return;\r\n      var etype = idObj.entityType || 'DEVICE';\r\n      var name  = e.name || e.entityName || e.title || id;\r\n      var pos   = byId[id] || byName[name];\r\n      if (!pos) return;\r\n      \r\n      // Initialize telemetry data object for all configured data keys\r\n      var telemetryData = {};\r\n      CONFIG.dataKeys.forEach(function(dk) {\r\n        telemetryData[dk.key] = null;\r\n      });\r\n      \r\n      out.push({\r\n        id: id,\r\n        entityType: etype,\r\n        name: name,\r\n        x: +pos.x,\r\n        y: +pos.y,\r\n        label: pos.label || name,\r\n        color: 'rgba(15,36,62,0.92)',\r\n        telemetry: telemetryData,\r\n        __pxLeft: 0,\r\n        __pxTop: 0\r\n      });\r\n    });\r\n    $scope.labels = out;\r\n    console.log('[FP] Labels built:', out.map(function (l) { return l.name; }));\r\n    // Colour chips based on the device's \"active\" attribute\r\n    out.forEach(function (label) {\r\n      var deviceEntityId = { entityType: label.entityType, id: label.id };\r\n      attributeService.getEntityAttributes(deviceEntityId, 'SERVER_SCOPE', ['active']).subscribe(\r\n        function (attrs) {\r\n          var isActive = false;\r\n          if (attrs && attrs.length) {\r\n            var a = attrs.find(function (x) { return x.key === 'active'; });\r\n            var v = a ? a.value : null;\r\n            if (typeof v === 'boolean') isActive = v;\r\n            else if (typeof v === 'string') isActive = v.toLowerCase() === 'true';\r\n            else if (typeof v === 'number') isActive = v === 1;\r\n          }\r\n          label.color = isActive ? 'rgba(76,175,80,0.9)' : 'rgba(244,67,54,0.9)';\r\n          ctx.detectChanges();\r\n        },\r\n        function (err) {\r\n          console.error('[FP] Failed to read active for', deviceEntityId, err);\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Apply post-processing formula to a raw value.\r\n   * The formula is a string expression where 'value' represents the raw data.\r\n   * Example: \"value/60\" converts seconds to minutes.\r\n   */\r\n  function applyFormula(rawValue, formula) {\r\n    if (!formula || formula.trim() === '') {\r\n      return rawValue;\r\n    }\r\n    try {\r\n      // Create a safe evaluation context\r\n      var value = rawValue;\r\n      var result = eval(formula);\r\n      return result;\r\n    } catch (err) {\r\n      console.error('[FP] Formula evaluation error:', err, 'Formula:', formula);\r\n      return rawValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start polling telemetry data for all configured data keys for a label's \r\n   * active job asset. Polling runs at the configured interval. If no active\r\n   * job exists, telemetry values are set to null.\r\n   */\r\n  function initTelemetryPolling(label) {\r\n    stopTelemetryPolling(label);\r\n    \r\n    function updateTelemetry() {\r\n      findActiveJobAsset(label, function (assetEntityId) {\r\n        if (assetEntityId) {\r\n          // Fetch all configured data keys\r\n          if (CONFIG.dataKeys && CONFIG.dataKeys.length > 0) {\r\n            var keys = CONFIG.dataKeys.map(function(dk) { return dk.key; });\r\n            var now = Date.now();\r\n            \r\n            attributeService.getEntityTimeseries(\r\n              assetEntityId,\r\n              keys,\r\n              0,\r\n              now,\r\n              1,\r\n              'NONE',\r\n              0,\r\n              'DESC',\r\n              false\r\n            ).subscribe(\r\n              function (data) {\r\n                CONFIG.dataKeys.forEach(function(dataKey) {\r\n                  var arr = data && data[dataKey.key];\r\n                  if (arr && arr.length) {\r\n                    var rawValue = arr[0].value;\r\n                    var processedValue = applyFormula(rawValue, dataKey.formula);\r\n                    \r\n                    // Format the value based on decimals setting\r\n                    var decimals = typeof dataKey.decimals === 'number' ? dataKey.decimals : 1;\r\n                    label.telemetry[dataKey.key] = processedValue != null ? \r\n                      Number(processedValue).toFixed(decimals) : null;\r\n                    \r\n                    console.log('[FP]', dataKey.key + ':', rawValue, \r\n                                '=> Processed:', label.telemetry[dataKey.key], \r\n                                'for device', label.name);\r\n                  } else {\r\n                    label.telemetry[dataKey.key] = null;\r\n                    console.log('[FP] No', dataKey.key, 'data for asset', assetEntityId.id);\r\n                  }\r\n                });\r\n                ctx.detectChanges();\r\n              },\r\n              function (err) {\r\n                console.error('[FP] Telemetry fetch error for', assetEntityId, err);\r\n                CONFIG.dataKeys.forEach(function(dataKey) {\r\n                  label.telemetry[dataKey.key] = null;\r\n                });\r\n                ctx.detectChanges();\r\n              }\r\n            );\r\n          }\r\n        } else {\r\n          // No active job, reset all telemetry values\r\n          CONFIG.dataKeys.forEach(function(dataKey) {\r\n            label.telemetry[dataKey.key] = null;\r\n          });\r\n          ctx.detectChanges();\r\n          console.log('[FP] No active job found for device', label.name);\r\n        }\r\n      });\r\n    }\r\n    \r\n    updateTelemetry();\r\n    var timerId = setInterval(updateTelemetry, CONFIG.pollInterval);\r\n    timers.set(label.id, timerId);\r\n    console.log('[FP] Started telemetry polling for device', label.name);\r\n  }\r\n\r\n  function stopTelemetryPolling(label) {\r\n    var tId = timers.get(label.id);\r\n    if (tId) {\r\n      clearInterval(tId);\r\n      timers.delete(label.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find the asset related to the device with job_status = 'active'.  The\r\n   * callback is invoked with the EntityId of the asset or null if no\r\n   * active job is found.\r\n   */\r\n  function findActiveJobAsset(label, callback) {\r\n    var fromEntity = { entityType: label.entityType || 'DEVICE', id: label.id };\r\n    relationService.findByFromAndType(fromEntity, 'ACTIVE_JOB').subscribe(\r\n      function (relations) {\r\n        console.log('[FP] findActiveJobAsset: relations for device', label.name, '=', relations);\r\n        if (!relations || relations.length === 0) {\r\n          callback(null);\r\n          return;\r\n        }\r\n        function checkRel(i) {\r\n          if (i >= relations.length) {\r\n            callback(null);\r\n            return;\r\n          }\r\n          var rel = relations[i];\r\n          var to  = rel && rel.to ? rel.to : null;\r\n          if (!to || !to.id) {\r\n            checkRel(i + 1);\r\n            return;\r\n          }\r\n          var assetEntityId = { entityType: to.entityType, id: to.id };\r\n          attributeService.getEntityAttributes(assetEntityId, 'SERVER_SCOPE', ['job_status']).subscribe(\r\n            function (attrs) {\r\n              var status = null;\r\n              if (attrs && attrs.length) {\r\n                var a = attrs.find(function (x) { return x.key === 'job_status'; });\r\n                status = a ? String(a.value).toLowerCase() : null;\r\n              }\r\n              console.log('[FP] findActiveJobAsset: job_status for asset', assetEntityId.id, '=', status);\r\n              if (status === 'active') {\r\n                console.log('[FP] Found active job asset', assetEntityId.id, 'for device', label.name);\r\n                callback(assetEntityId);\r\n              } else {\r\n                checkRel(i + 1);\r\n              }\r\n            },\r\n            function (err) {\r\n              console.error('[FP] job_status read error for', assetEntityId, err);\r\n              checkRel(i + 1);\r\n            }\r\n          );\r\n        }\r\n        checkRel(0);\r\n      },\r\n      function (err) {\r\n        console.error('[FP] relation fetch error for device', label.id, err);\r\n        callback(null);\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get telemetry keys with their display values for a specific label.\r\n   * This function is called by the HTML template to render telemetry data.\r\n   */\r\n  function getTelemetryKeys(label) {\r\n    if (!CONFIG.dataKeys || !label || !label.telemetry) {\r\n      return [];\r\n    }\r\n    return CONFIG.dataKeys.map(function(dk) {\r\n      var value = label.telemetry[dk.key];\r\n      var displayValue = value != null ? value + (dk.unit || '') : '--';\r\n      return {\r\n        key: dk.key,\r\n        label: dk.label || dk.key,\r\n        displayValue: displayValue\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Click handler for the machine chip.  Finds the active job asset and\r\n   * navigates to the configured dashboard state with the asset as the\r\n   * state parameter.  If no active job is found, shows a toast.\r\n   */\r\n  function clickDevice(label) {\r\n    var sc = ctx.stateController;\r\n    if (!sc) {\r\n      console.warn('[FP] State controller not available; cannot navigate.');\r\n      return;\r\n    }\r\n    console.log('[FP] clickDevice: clicked', label.name);\r\n    findActiveJobAsset(label, function (assetEntityId) {\r\n      if (assetEntityId) {\r\n        var params = {};\r\n        params[CONFIG.stateParamName] = {\r\n          entityId: { entityType: assetEntityId.entityType, id: assetEntityId.id },\r\n          entityName: label.name,\r\n          entityLabel: label.label\r\n        };\r\n        params.targetEntityParamName = CONFIG.stateParamName;\r\n        console.log('[FP] Navigating to', CONFIG.targetStateId, 'with params', params);\r\n        sc.openState(CONFIG.targetStateId, params, false);\r\n      } else {\r\n        console.warn('[FP] No active job found; navigation cancelled for', label.name);\r\n        ctx.showInfoToast('Machine not planned');\r\n      }\r\n    });\r\n  }\r\n};",
      "settingsForm" : [ {
        "id" : "imageUrl",
        "name" : "Background Image",
        "type" : "image",
        "default" : "tb-image;/api/images/tenant/480c9266064172a4f50c40fc682092b5.jpg"
      }, {
        "id" : "groupId",
        "name" : "Device Group ID",
        "type" : "text",
        "defaultValue" : "45504450-ae8f-11f0-a60f-a7f9e67d958a"
      }, {
        "id" : "targetStateId",
        "name" : "Target State ID",
        "type" : "text",
        "defaultValue" : "job_dashboard"
      }, {
        "id" : "stateParamName",
        "name" : "State Parameter Name",
        "type" : "text",
        "defaultValue" : "jobcard"
      }, {
        "id" : "positions",
        "name" : "Label Positions (JSON Array)",
        "type" : "json",
        "defaultValue" : [ {
          "by" : "name",
          "match" : "RUT200-1",
          "x" : 20,
          "y" : 30,
          "label" : "RUT200-1"
        }, {
          "by" : "name",
          "match" : "MACHINE #1",
          "x" : 40,
          "y" : 50,
          "label" : "MACHINE #1"
        }, {
          "by" : "name",
          "match" : "ITL ECU",
          "x" : 60,
          "y" : 70,
          "label" : "ITL ECU"
        } ]
      }, {
        "id" : "dataKeys",
        "name" : "Telemetry Data Keys (JSON Array)",
        "type" : "json",
        "defaultValue" : [ {
          "key" : "runtime_s",
          "label" : "Runtime",
          "formula" : "value/60",
          "decimals" : 1,
          "unit" : " min"
        } ]
      }, {
        "id" : "pollInterval",
        "name" : "Polling Interval (ms)",
        "type" : "number",
        "defaultValue" : 5000
      } ],
      "dataKeySettingsForm" : [ ],
      "settingsDirective" : "",
      "hasBasicMode" : false,
      "defaultConfig" : "{\"datasources\":[{\"type\":\"static\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":false,\"backgroundColor\":\"rgb(255, 255, 255)\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"cardHtml\":\"<div class='card'>HTML code here</div>\",\"cardCss\":\".card {\\n    font-weight: bold;\\n    font-size: 32px;\\n    color: #999;\\n    width: 100%;\\n    height: 100%;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\"},\"title\":\"HTML Card\",\"dropShadow\":true}"
    },
    "externalId" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "3e5ab600-b252-11f0-ba19-01c0db8b26bf"
    },
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "3e5ab600-b252-11f0-ba19-01c0db8b26bf"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}